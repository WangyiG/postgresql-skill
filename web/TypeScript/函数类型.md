## 函数的类型
在JavaScript中,有两种常见定义函数的方式:
- 函数声明（Function Declaration）
```js
// 声明了一个叫add的函数
function add(m,n){
  return m + n;
  }
```

- 函数表达式（Function Expression）
```js
// 把一个函数赋值给add
const add_1 = function(m,n){
    return m + n;
    }
// 或者写做一个箭头函数
const add_2 = (m,n) => {
    return m + n;
    }
```
- 在ts中,要对函数的输入输出都进行约束,函数声明很方便约束：
```ts
 function add(m: number,n: number): number{
    return m + n;
    }
```
- 需要注意的是函数表达式的输出约束得仔细辨认是手动约束还是类型推导出的
```ts
// 手动约束2边的类型
// 在TypeScript的类型定义中,=> 用来表示函数的定义,左边是输入类型,需要用括号括起来,右边是输出类型
// ES6中的 => 是箭头函数
const mySum: (x: number, y: number) => number = function (x: number, y: number): number {
    return x + y;
}

// 以上左边也可以使用接口来定义
interface SumFunc {
    (source: string, subString: string): boolean;
}
let mySum: SumFunc;
mySum = function (x: number, y: number): number {
    return x + y;
}

// 通过类型推导,不仅推导了左边,整个输出都类型推导了
const mySum = function (x: number, y: number){
    return x + y;
}
```
## 用 ? 表示可选参数
需要注意的是
- 可选参数必须接在必需参数后面
- 除非可选参数是一个默认参数(虽然可以写在前面,但传参时必须还得传一个undefined,但默认参数写在后面是可以不必传参的)
```ts
function buildName(firstName?: string, lastName: string) {
    if (firstName) {
        return firstName + ' ' + lastName;
    } else {
        return lastName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName(undefined, 'Tom');
```

## 使用 ...rest 的方式获取函数中的剩余参数
```ts
// py中的*args
function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
    return array
}
console.log(push([],1,2,3));
```
数组的foreach属性
```js
items = [1,2,3]
items.forEach(function(item){
    console.log(item)
})
items.forEach((item) => {
    console.log(item+1)
})
```
## 重载
接收不同的参数类型做不同的操作
```ts
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
```










