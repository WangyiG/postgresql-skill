## 2个视图基类
- APIView
```py
from rest_framework.views import APIView
'''
APIView是drf所有视图的基类,继承自Django的View父类
APIView与View的不同之处在于：
1.传入到视图方法中的是drf的Request对象(主要解决POST请求支持Json格式编码数据),而不是Django的HttpRequeset对象(其POST不支持json格式编码数据)
2.视图方法可以返回drf中的Response对象,视图会为响应数据设置（render）符合前端要求的格式
3.任何APIException异常都会被捕获到，并且处理成合适的响应信息
4.在进行dispatch()分发前,会对请求进行身份认证、权限检查、流量控制

支持定义的类属性：
rederer_classes 支持响应的编码格式
parser_classes  支持解析的编码格式
authentication_classes 列表或元组，身份认证类
permissoin_classes 列表或元组，权限检查类
throttle_classes 列表或元组，流量控制类
'''
```
- GenericAPIView,数据库api常用(queryset),APIView常用于第三方api如短信发送api
```py
from rest_framework.generics import GenericAPIView
'''
继承自APIView,主要增加了操作序列化器和数据库查询的属性与方法
设置类属性：
  1.queryset = 指定qs对象,ex:Book.objects.all()
  2.serializer_class = 指定序列化器,ex:BookSerializer
  3.lookup_filed = 'pk'
  4.filter_backends 过滤功能使用
  5.pagination_class 分页功能使用
利用新方法隐式调用类属性修改请求函数,优点是请求方法都去绑定类属性,以后复用只需修改类属性即可：
  1.get_queryset
    ex: book_list = Book.objects.all() 变成 obj = self.get_queryset()
    扩展：重写get_queryset,py的查找顺序是先找我们重写的get_queryset,找到后不再去找父类GenericAPIView的get_queryset方法
    def get_queryset(self)：
      if self.request.path == 'xxx':
        return other_model.objects.xxx
       return Author.objects.all()
  2.get_object
    ex: book=Book.objects.filter(pk=pk).first()变为obj=self.get_object()
    请求函数中需要有pk参数,get_object源码自动找pk,get_object方法不必传pk
    注意delete请求需要在调用后继续调用delete(),obj=self.get_object().delete()等同于Book.objects.filter(pk=pk).first().delete()
  3.get_serializer
    ex: ser = BookSerializer(instance=book_list,many=True) 变成ser = self.get_serializer(instance=obj,many=True)
    get_serializer方法根据请求函数的不同，需要传参[instance,many,data]

'''
```

## 5个视图扩展类
- 不是视图类,不继承APIView,需要与GenericAPIView搭配食用
- GenericAPIView用于固定queryset与serializer_class
- 视图扩展类用于继续封装简化请求函数
```py
from rest_framework.mixins import ListModelMixin,RetrieveModelMixin,CreateModelMixin,UpdateModelMixin,DestroyModelMixin
'''
1.ListModelMixin        查询多个,旧函数many = True了,给封装了
2.RetrieveModelMixin    查询单个
3.CreateModelMixin      新增
4.UpdateModelMixin      修改,旧函数既要instance也要data,也给封装了
5.DestroyModelMixin     删除 
'''
# 原get请求函数
def get(self,request):
  obj = self.get_queryset()
  ser = self.get_serializer(instance = obj,many = True)
  return Response(ser.data)
# 新get请求函数,继承ListModelMixin
def get(self,request):
  return super().list(request)
# 原post请求函数
def post(self,request):
  ser = self.get_serializer(data = request.data)
  if ser.is_valid():
    ser.save()
    return Response(ser.data)
# 新post请求函数,继承CreateModelMixin
  # 扩展:重写perform_create,增加校验等功能,通过之后再报存
  def perform_create(self,serializer):
    assert 1<2,'1应当小于2'
    serializer.save()
def post(self,request):
  return super().create(request)
 
 
# 原put请求函数
def put(self,request):
  obj = self.get_object()
  ser = self.get_serializer(instance = obj,data = request.data)
  if ser.is_valid():
    ser.save()
    return Response(ser.data)
# 新put请求函数,继承UpdateModelMixin
def put(self,request,*args,**kwargs):
  return super().update(request,*args,**kwargs)
```
## 9个视图子类
- GenericAPIView用于固定queryset与serializer_class
- 视图扩展类用于继续封装简化请求函数
- 视图子类继承自视图扩展类组合及GenericAPIView
- 视图子类用于**组合生成**请求函数,不必再写请求函数
```py
from rest_framework.generics import ListAPIView,RetrieveAPIView,CreateAPIView,UpdateAPIView,DestroyAPIView
from rest_framework.generics import ListCreateAPIView,RetrieveDestroyAPIView,RetrieveUpdateAPIView,RetrieveUpdateDestroyAPIView
'''
1.ListAPIView       get全部
2.RetrieveAPIView   get单个
3.CreateAPIView     新增
4.UpdateAPIView     修改
5.DestroyAPIView    删除
6.ListCreateAPIView   get与post
7.RetrieveDestroyAPIView   get单个与删除
8.RetrieveUpdateAPIView    get单个与修改
9.RetrieveUpdateDestroyAPIView     get单个与修改和删除
'''

# 1.未使用视图子类创建get与post
def get(self,request):
  return super().list(request)
def post(self,request):
  return super().create(request)
# 2.使用视图子类创建自动创建(是的,不必再写请求函数),继承ListCreateAPIView,ListCreateAPIView继承于ListModelMixin,CreateModelMixin,GenericAPIView
```
## 视图集
- 视图集扩展类ViewSetMixin,不是视图类,一般用于自动生成路由
- 视图集视图类ViewSet,GenericViewSet,自动生成路由
```py
from rest_framework.viewsets import ViewSet,GenericViewSet
'''
ViewSet继承ViewSetMixin, views.APIView
GenericViewSet继承ViewSetMixin, generics.GenericAPIView
'''
```
- 视图集模型视图类ModelViewSet,ReadOnlyModelViewSet
```py
from rest_framework.viewsets import ModelViewSet,ReadOnlyModelViewSet
'''
ModelViewSet继承全部5个视图扩展类和GenericViewSet(即:ViewSetMixin, generics.GenericAPIView)
ReadOnlyModelViewSet继承查询多个与查询单个视图扩展类mixins.RetrieveModelMixin, mixins.ListModelMixin和GenericViewSet
'''
```
- 在视图子类中我们将接口函数都合一了,但是我们仍然要对一个表模型写2个视图类,分别继承视图子类(因为视图子类没有解决掉路由带pk与不带pk合一的问题)
- 视图集搭配路由组件解决了路由合一的问题

## 路由组件
- 2个路由基类
```py
from rest_framework.routers import SimpleRouter,DefaultRouter
# DefaultRouter仅仅比SimpleRouter多了一个根路由可以访问
```
- 路由组件的使用
```py
# 先实例化
router =  DefaultRouter()
# 注册继承于视图集的视图类的路由
router.register('books',BookViewSet,'别名')
# 路由注册后router.urls会自动生成不带pk与带pk2种路由
# 将router.urls添加到urlpatterns中的2种方式
1.urlpatterns = [...,path('api/v1',include(router.urls)]
2.urlpatterns += router.urls
# 以上操作实际类似如下,其中as_view开始接收参数,意为get请求实际调用BookViewSet的list方法,也即BookViewSet中的get请求方法函数名可以不叫get
urlpatterns = [...,path('books',views.BookViewSet.as_view({'get':'list})]
```
- 路由组件中的action声明
```py
# 导入
form rest_framework.decorators import action
# 从导入就可以看出action是个装饰器接收2个参数,methods = 请求方式列表,detail = 是否与单一资源对应
@action(methods=['get'],detail = false)
def get_new(self,request):
  obj = self.get_queryset()
  ser = self.get_serializer(instance = obj,many = True)
  return Response(ser.data)
  
@action(methods=['get'],detail = True)
def get_new(self,request,pk):
  obj = self.get_object()
  ser = self.get_serializer(instance = obj)
  return Response(ser.data) 
```

