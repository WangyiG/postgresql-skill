# 登陆接口
## 创建新项目与app
```sh
django-admin startproject logindemo
cd logindemo
django-admin startapp loginapp
```
## 新建数据库
```sql
create database drf_login
```
## 项目配置
```py
# 注册rest_framework与loginapp
INSTALLED_APPS = [
     ...,
    'rest_framework',
    'loginapp.apps.LoginappConfig'
]

# 配置数据库
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',     
        'NAME': 'drf',                              
        'USER': 'mt',                                  
        'PASSWORD': 'postgres',                        
        'HOST': '127.0.0.1',
        'PORT': '5432',
      }
    }

# 配置本地化
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True
USE_L10N = True
USE_TZ = False
```
## 配置表模型并激活
```py
from django.db import models


class User(models.Model):
    username = models.CharField(max_length=32)
    password = models.CharField(max_length=32)
    # 通过实例的get_字段_display()方法来取对应字符串
    user_type = models.IntegerField(choices=((0, '超级用户'), (1, '管理员'), (2, '普通用户')))


class UserToken(models.Model):
    # 注意on_delete参数不要漏
    name = models.OneToOne(to=User,on_delete=models.CASCADE)
    token = models.TextField()
```
```sh
python manage.py makemigrations
python manage.py migrate
```
## 配置视图类
```py
# 注意UserView并没有使用序列化器,存的queryset对象,响应的也是前端可识别的对象而非qs对象
class UserView(ViewSet):
    @action(methods=['POST'], detail=False)
    def login(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        user = User.objects.filter(username=username, password=password).first()
        print(user.username,user.password,user.user_type)
        if user:
            # 登陆成功
            token = str(uuid.uuid4())
            # 根据name检索,如果有token则更新,没有token则新增
            UserToken.objects.update_or_create(name=user, defaults={'token': token})
            # 将token给到前端
            return Response({'code': 100, 'msg': '登陆成功', 'token': token})
        else:
            return Response({'code': 101, 'msg': '用户名或密码错误,登陆失败'})

```
## 配置路由
```py
# 主路由
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('loginapp/', include('loginapp.urls')),
]

# 子路由
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('user', views.UserView, 'user')     # 生成的路由是user/请求函数名/,正常只有‘user/’，而‘请求函数名/’ 实际是由视图中action生成
urlpatterns = [
    path('', include(router.urls)),
]
```
## 启动项目测试API
```sh
python manage.py runserver   # api路径:http://127.0.0.1:8000/loginapp/user/login/
```

# 认证
## 添加表模型并激活
```py
# 该表模型的接口访问必须经过登陆,权限，频率认证过后才能访问
class Book(models.Model):
     name = models.CharField(max_length=32)
     price = models.IntegerField()
     author = models.CharField(max_length=32)
```
```sh
cd logindemo
python manage.py makemigrations
python manage.py migrate
```
## app目录下新建序列化器文件serializer.py
```py
from rest_framework.serializers import ModelSerializer
from .models import Book


class BookSerializer(ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'
```
## 添加视图类
```py
from .models import User, UserToken, Book
from .serializer import BookSerializer
from rest_framework.viewsets import ViewSet, ReadOnlyModelViewSet,GenericViewSet
from rest_framework.mixins import CreateModelMixin, UpdateModelMixin, DestroyModelMixin


# 写2个视图类,为后续权限分离做准备,只读接口对所有用户开放,新增修改删除接口不对普通用户开发
class BookView(ReadOnlyModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer

class BookDetailView(GenericViewSet, CreateModelMixin, UpdateModelMixin, DestroyModelMixin):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
```

## 给新视图配置子路由
```py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('user', views.UserView, 'user')
router.register('books', views.BookView, 'books')
router.register('book_detail', views.BookDetailView, 'book_detail')
urlpatterns = [
    path('', include(router.urls)),
]
```
## app目录下新建认证文件auth.py
```py
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from .models import UserToken

# 继承BaseAuthentication重写authenticate方法,在方法中做校验是否登陆成功
# 校验未通过抛异常,校验成功返回当前用户与token字符串

# 创建认证类
class LoginAuth(BaseAuthentication):
    def authenticate(self, request):
        # 获取token,这里假设token在请求地址中类如:https://host:8000/books/?token = xxx
        token = request.query_params.get('token')
        # 请求地址中的token是否存在
        user_token = UserToken.objects.filter(token=token).first()
        if user_token:
            return user_token.name, token
        else:
            # 认证失败异常
            raise AuthenticationFailed('请先登陆')
```
##  使用认证
- 全局使用,配置setting.py
```py
REST_FRAMEWORK = {
     "DEFAULT_AUTHENTICATION_CLASSES":["loginapp.auth.LoginAuth"]
}
```
- 局部禁用(配置了全局才会局部禁用)
```py
from .auth import LoginAuth
class BookView(ReadOnlyModelViewSet):
    # 执行顺序是当前类,父类,全局
    authentication_classes = []
```
- 局部使用,在视图类中配置
```py
from .auth import LoginAuth
class BookView(ReadOnlyModelViewSet):
    # authentication_classes是APIView的类属性,而ReadOnlyModelViewSet继承自APIView
    authentication_classes = [LoginAuth, ]
    queryset = Book.objects.all()
    serializer_class = BookSerializer
```
## 测试API认证
```sh
http://127.0.0.1:8000/loginapp/books/
```
# 权限
- 登陆成功后,普通用户只能访问只读
## 在认证文件auth.py中创建权限类
```py
from rest_framework.permissions import BasePermission

# 继承BasePermission重写has_permission方法,在方法中做校验是否有权限
# 权限验证在登陆验证之后,所以可以request.user获取当前登陆用户
# 如果用户当前没有登录,request.user将设置为django.contrib.auth.models.AnonymousUser的一个实例,可以通过is_authenticated()区分它们

class UserPermission(BasePermission):
    def has_permission(self, request, view):
        # 可自定义提示信息,get_user_type_display()来自于模型字段参数choices
        self.message = f'您是{resquest.user.get_user_type_display()}无权操作,请联系管理员'
        # 如果有权限返回True,无权限返回False
        user_type = request.user.user_type
        if user_type < 2:
            return True
        else:
            return False
```
## 权限的使用
- 全局使用
```py
REST_FRAMEWORK = {
     "DEFAULT_PERMISSION_CLASSES":["loginapp.auth.LoginAuth"]
}
```
- 视图层局部禁用
```py

class BookDetailView(GenericViewSet, CreateModelMixin, UpdateModelMixin, DestroyModelMixin):
    authentication_classes = [LoginAuth, ]
    # 指定权限类属性为空则禁用,执行顺序:当前类,父类,全局
    permission_classes = []

```
- 视图层局部使用
```py
from .auth import UserPermission

# 非只读接口,设置访问权限
class BookDetailView(GenericViewSet, CreateModelMixin, UpdateModelMixin, DestroyModelMixin):
    authentication_classes = [LoginAuth, ]
    permission_classes = [UserPermission, ]
```
## API测试
```sh
// 先登陆,POST请求,响应中有token
http://127.0.0.1:8000/loginapp/user/login/
// 如果已登陆,后台可取当前登陆用户,并校验用户权限
http://127.0.0.1:8000/loginapp/book_detail/2/?token=...
```
# 频率
-  一般在认证和权限都通过后,限制访问频率,可基于ip或用户等来限制
## 在认证文件auth.py中创建频率类
```py

# 继承SimpleRateThrottle(继承自BaseThrottle)重写get_cache_key方法,在方法中return要限制的对象
# 类属性scope指定限制标签,在全局配置中需要配置DEFAULT_THROTTLE_RATES项指定每个标签对应的限制规则

class IPThrottle(SimpleRateThrottle):
    scope = 'minute-3'

    def get_cache_key(self, request, view):
        # 返回什么就以什么做限制,这里限制ip,从request.META(请求头数据字典)中取REMOTE_ADDR客户端的ip地址
        # return request.user.id ,以用户id做限制,注意做限制的数据应unique,防止比如同名限制
        return request.META.get('REMOTE_ADDR')
```
## 全局配置DEFAULT_THROTTLE_RATES项
- 频率校验不一定要全局使用,但一旦使用频率校验,其具体限制规则应当全局可用
```py
REST_FRAMEWORK = {
    #  "DEFAULT_THROTTLE_CLASSES": ["loginapp.auth.IPThrottle"]频率校验全局使用
    "DEFAULT_THROTTLE_RATES": {
        'minute-3': '3/m',
        'label':'3/h'
    }
}
```
## 视图层局部使用
```py
from .auth import IPThrottle

class BookDetailView(GenericViewSet, CreateModelMixin, UpdateModelMixin, DestroyModelMixin):
    authentication_classes = [LoginAuth, ]
    permission_classes = [UserPermission, ]
    # 空列表则表示禁用校验
    throttle_classes = [IPThrottle, ]
    queryset = Book.objects.all()
    serializer_class = BookSerializer
```









































