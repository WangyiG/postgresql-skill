## 过滤
- 过滤只适用查询所有接口
#### 新建一个示例app并注册
```sh
python manage.py startapp filter_app
```

#### 配置表模型并激活
```py
from django.db import models


class Book(models.Model):
    name = models.CharField(max_length=32)
    price = models.IntegerField()
    author = models.CharField(max_length=32)
```
#### 新建序列化器文件serializer.py
```py
from rest_framework import serializers
from .models import Book


class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'
```
#### 新建自定义过滤类filter.py
```py
from rest_framework.filters import BaseFilterBackend


# 写一个类继承BaseFilterBackend,重写filter_queryset方法,返回过滤后的对象
class BookFilter(BaseFilterBackend):
    def filter_queryset(self, request, queryset, view):
        # 指定过滤字段
        query = request.query_params.get('name')
        if query:
            # 指定匹配方式为模糊匹配
            queryset = queryset.filter(name__contains=query)
        return queryset
```
#### 配置视图类
```py
from .serializer import BookSerializer
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ViewSetMixin
from rest_framework.filters import SearchFilter
from django_filters.rest_framework import DjangoFilterBackend
from .filter import BookFilter

# 第一种过滤类,内置的SearchFilter
## 过滤字段的指定使用search_fields
## 内置的过滤类必须使用?search=xx来过滤,且不支持并查询
from rest_framework.filters import SearchFilter


class BookView1(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView
    filter_backends = [SearchFilter, ]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    search_fields = ['name', 'author']


# 第二种过滤类,第三方类DjangoFilterBackend
## 安装:pip install django-filter
## 在配置文件中注册,注意的注册的是django_filters而非django-filter
## 过滤字段的指定使用filterset_fields
## 该过滤类不支持模糊匹配,但支持name=xx&author=xx多项匹配


class BookView2(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView,filter_backends用于指定使用那种过滤类
    filter_backends = [DjangoFilterBackend, ]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    filterset_fields = ['name', 'author']
    

# 第三种过滤类,自定义过滤类
# 导入filter.py文件中的自定义过滤类,filter_backends指定使用自定义过滤类
# 过滤字段的指定在自定义过滤中已指定,不必再指定过滤字段
class BookView3(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView,filter_backends用于指定使用那种过滤类
    filter_backends = [BookFilter, ]
```
#### 配置路由
```py
# 主路由
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    ... ,
    path('filter_app/', include('filter_app.urls')),
]
# 子路由
from django.urls import path, include
from .views import BookView
from rest_framework.routers import DefaultRouter


router = DefaultRouter()
router.register('books', BookView, 'books')

urlpatterns = [
    path('', include(router.urls)),
]
```
#### 运行项目测试带过滤的API
```sh
python manage.py runserver
```
- 接口地址
```sh
http://127.0.0.1:8000/filter_app/books1/?search=梦
http://127.0.0.1:8000/filter_app/books2/?name=红楼梦&author=曹雪芹
http://127.0.0.1:8000/filter_app/books3/?name=梦
```
## 排序
- 排序也只适用查询所有接口
- 排序可与过滤结合使用,从消耗来说通常先过滤再排序
- 倒序的使用:-filed
#### 在视图类中使用排序
```py
from .models import Book
from .serializer import BookSerializer
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ViewSetMixin
from rest_framework.filters import SearchFilter, OrderingFilter

# filter_backends即可以指定过滤类也可以同时指定排序类
# filter_backends 指定排序字段
class BookView1(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView
    filter_backends = [SearchFilter, OrderingFilter]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    search_fields = ['name', 'author']
    # 指定排序的字段,如果price一致再按id排序
    ordering_fields = ['price','id']
    
```
- 接口地址
```sh
http://127.0.0.1:8000/filter_app/books1/?search=梦&ordering=price,-id
```
## 分页
- 分页同样只适用于查询所有接口
- 在小程序或app中分页常见是下拉形式
#### 新建分页文件page.py
- 分页有三种形式,普通分页,偏移分页,游标分页
```py
from rest_framework.pagination import PageNumberPagination, LimitOffsetPagination, CursorPagination

# 普通分页
# 继承PageNumberPagination,重写4个类属性
class BookPageNumberPagination(PageNumberPagination):
    # 默认每页显示条数
    page_size = 3
    # 页参数名,第n页传page=n
    page_query_param = 'page'
    # 自定义每页条数参数名,默认每页显示条数3,指定不按默认条数显示按5条显示,传入size=5
    page_size_query_param = 'size'
    # 每页最大显示条数,默认显示条数与自定义显示条数受最大显示条数约束
    max_page_size = 5
    
    
# 偏移分页
# 继承LimitOffsetPagination,重写4个类属性
class BookLimitOffsetPagination(LimitOffsetPagination):
    # 默认每页显示条数
    default_limit = 3
    # 自定义每页条数参数名,默认每页显示条数3,指定不按默认条数显示而按5条显示,传入limit=5
    limit_query_param = 'limit'
    # 指定查询的起始条目,从第n+1条开始查询m条,使用offset=n&limit=m
    offset_query_param = 'offset'
    # 每页最大显示条数,默认显示条数与自定义显示条数受最大显示条数约束
    max_limit = 5
    
    
# 游标分页
# 该分页方式效率高,不从起始页开始维护,只维护当前页、上一页、下一页
# 与排序OrderingFilter冲突,不支持全数据的排序维护
# 继承CursorPagination,重写3个类属性
class BookCursorPagination(CursorPagination):
    # 默认每页显示条数
    page_size = 3
    # 游标参数名,该参数不必手动传参,自动生成上一页与下一页游标参数
    cursor_query_param = 'cursor'
    # 排序依据,不一定是字段,可以使用数据库维护的创建时间如:-create
    ordering = 'id'
```
#### 在视图类中使用分页
- 使用pagination_class指定排序类,分页只能使用一种方式,不再接收列表多模式指定
##### 普通分页
```py
from .models import Book
from .serializer import BookSerializer
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ViewSetMixin
from rest_framework.filters import SearchFilter, OrderingFilter
from .page import BookPageNumberPagination

class BookView1(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView
    filter_backends = [SearchFilter, OrderingFilter]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    search_fields = ['name', 'author']
    # 指定排序字段,如果price一致再按id排序
    ordering_fields = ['price', 'id']
    # 指定排序类,分页只能使用一种方式,不再接收列表多模式指定
    pagination_class = BookPageNumberPagination
```
- 接口地址
```sh
http://127.0.0.1:8000/filter_app/books1/?size=4
http://127.0.0.1:8000/filter_app/books1/?page=2&size=4
```
##### 偏移分页
```py
from .models import Book
from .serializer import BookSerializer
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ViewSetMixin
from rest_framework.filters import SearchFilter, OrderingFilter
from .page import BookPageNumberPagination,BookLimitOffsetPagination

class BookView1(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # filter_backends继承于GenericAPIView
    filter_backends = [SearchFilter, OrderingFilter]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    search_fields = ['name', 'author']
    # 指定排序字段,如果price一致再按id排序
    ordering_fields = ['price', 'id']
    # 指定排序类,分页只能使用一种方式,不再接收列表多模式指定
    pagination_class = BookLimitOffsetPagination
```
- 接口地址
```sh
http://127.0.0.1:8000/filter_app/books1/?offset=2&limit=4
```
##### 游标分页
- **注意**:游标分页与OrderingFilter冲突
```py
from .models import Book
from .serializer import BookSerializer
from rest_framework.generics import ListAPIView
from rest_framework.viewsets import ViewSetMixin
from rest_framework.filters import SearchFilter, OrderingFilter
from .page import BookPageNumberPagination,BookLimitOffsetPagination, BookCursorPagination

# 游标分页的使用需要取消掉OrderingFilter
class BookView1(ViewSetMixin, ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    # 游标分页不支持OrderingFilter
    filter_backends = [SearchFilter]
    # 指定过滤的字段,模糊的或查询(name中模糊匹配到或author中模糊匹配到)
    search_fields = ['name', 'author']
    # 指定排序类,分页只能使用一种方式,不再接收列表多模式指定
    pagination_class = BookLimitOffsetPagination
```
- 接口地址
```sh
http://127.0.0.1:8000/filter_app/books1/
```

