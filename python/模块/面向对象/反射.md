## 概念与核心
**反射是通过字符串来操作类或对象的属性与方法**
1. hasattr：判断一个属性或方法是否存在与这个类中
2. getattr：根据字符串去获取obj对象里的对应的方法的内存地址，加"()"括号即可执行
3. setattr：通过setattr将外部的一个函数绑定到实例中
4. delattr：删除一个实例或者类中的方法

## hasattr
- hasattr(obj,attr),判断obj对象是否有attr属性,其中attr以字符串形式传参
```py
class A:
    type_ = 'cat'
    def __init__(self,name):
        self.name = name
    
    def say(self):
        return f'Hi,I am a {self.type_},My name is {self.name}'

a = A('kite')
a.say()

# 只有第三个为False
hasattr(A,'say'),hasattr(A,'type_'),hasattr(A,'name'),hasattr(a,'say'),hasattr(a,'type_'),hasattr(a,'name')
```

## getattr
```py
getattr(A,'type_')                   # 'cat'
getattr(A,'name',None)               #  如果获取不到报AttributeError,可指定第三参数,设置获取不到的返回值
getattr(A,'say')                     #  类中有一个实例方法say,调用必须传实例getattr(A,'say')(a)
getattr(a,'say')                     #  返回实例方法内存地址
getattr(a,'say')()                   #  加括号调用,返回:'Hi,I am a cat,My name is kite' 
getattr(a,'name')                    #  'kite'
```

## setattr
```py
def eat():
    return 'eatting fish'
    
setattr(a,'color','yellow')  # 给a设置color属性,值为yellow
setattr(a,'eat',eat)         # 给a设置eat方法,绑定eat函数的内存地址,a.eat()调用
```
## delattr
```py
delattr(a,'eat')
delattr(a,'color')
```
## __getattr__魔法方法
- 不存在的属性会去getattr中查一下
```py
class A:
    type_ = 'cat'
    def __init__(self,name):
        self.name = name
    
    def say(self):
        return f'Hi,I am a {self.type_},My name is {self.name}'

    def __getattr__(self,attr):
        print('执行getattr')
        pass

a = A('kite')

a.say()
a.color   # 执行getattr
```
## __getattribute__魔法方法
- 无论属性是否存在,优先执行getattribute
```py
class B:
    type_ = 'cat'
    def __init__(self,name):
        self.name = name
    
    def say(self):
        return f'Hi,I am a {self.type_},My name is {self.name}'

    def __getattribute__(self,attr):
        print('实际存在的属性也未执行,强制执行getattribute')
        pass

b = B('petch')

b.name  # 执行getattribute中的print
```
