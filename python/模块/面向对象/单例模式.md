## 单例模式
保证全局环境下只能有一个该类的实例,所有类实例指向同一个内存地址
## 单例模式的三种实现
#### __new__实现
```py
class User:
    _instance = None
    def __new__(cls, *args,**kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self,name):
        self.name = name

u1 = User('mt1')
u1.age = 18
u2 = User('mt2')

u1.name,u2.age  #返回:('mt2', 18)
```
#### 装饰器实现
```py
instances = {}
def singleton(cls):
    def get_instance(*args,**kwargs):
        cls_name = cls.__name__
        if  cls_name not in instances:
            instance = cls(*args,**kwargs)
            instances[cls_name] = instance
        return instances[cls_name]
    return get_instance

@singleton
class Author:
    _instance = None
    def __init__(self,name):
        self.name = name
a1 = Author('mt1')
a1.age = 18
a2 = Author('mt2')

a1.name,a2.age  # 返回:('mt1', 18)
```
#### 元类实现
```py
class MetaSingleton(type):
    def __call__(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            cls._instance = type.__call__(cls, *args, **kwargs)
        return cls._instance

class User(metaclass=MetaSingleton):
    def __init__(self, *args, **kw):
        for k,v in kw:
            setattr(self, k, v)

u1 = User()
u1.name = 'mt1'
u1.age = 18
u2 = User()
u2.name = 'mt2'


u1.name,u2.age,u1 is u2    # 返回:('mt2', 18, True)

setattr(u2,'color','red')
u1.color                   # 返回:'red'
```
