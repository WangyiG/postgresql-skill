-- select * 效率低的原因
1.不需要的列会增加数据传输时间和网络开销

1(1).数据库需要解析更多不需要的对象,权限,属性等内容,在sql语句复杂,硬解析较多时会给数据库带来沉重负担
1(2).*有时会带上如log,lconMD5之类无用且大的文本字段,数据传输size几何增长,尤其是sql服务器与客户端不在同一台机器时,通信时间长

2.无用的大字段如varchar、blob、text如果长度超过728字节时,会把超出部分序列号存入别的地方,此时读取该记录会增加io操作

3.失去覆盖索引策略优化的可能性,当有1个表a、b、c、d、e,其中a为主键,b列上有索引,这里不妨把a当作聚集索引,把b当作辅助索引,当b列能过滤掉的数据比聚集索引能过滤的多的多时,也即通过
b索引就能命中想要的结果,此时可以视做一次索引覆盖(女朋友自己就能做的事覆盖了男朋友的作用),查询select a,b where b很可能是通过辅助索引从内存中读取,而select *很可能要会降低b索引
的命中从而需要再通过a索引去过滤,一是多去扫描一次,增加了扫描时间,更恶劣的是可能要去读取更多在磁盘中的数据,磁盘与内存的速度差异更加明显


-- 联合索引
1.联合索引a、b、c实际建立了(a),(a,b),(a,b,c)三个索引
注意:没有(a,c)与(b,c),联合索引存在层级关系,必须使用了上级索引才能使用下级索引,用了a才能用b,用了ab才能用c,用了a未用b则不能用c,至于bc,b在a未用的情况下本身就不可命中,更不论下级c了

2.联合索引的优势
2(1).减少开销,每增加一个索引,都会增加写操作的开销与磁盘空间的开销,联合索引虽然建立了多个索引,但物理层面上虽然比单列索引大但比3个单列索引小
2(2).覆盖索引:假设有where a= b= [c=] sql可以直接遍历索引取数据无需回表,减少大量io
2(3).效率高:假设每个条件可以过滤90%数据,1000w联合索引可以直接过滤到0.1*0.1*0.1*1000w=1w,单列索引则是1000w*0.1,然后回表从100w中再去根据别的小妖精取数、排序、分页

-- 索引越多越好吗？
否
1.数据量小的表不需要建立索引,甚至反而增加索引开销,形成负优化
2.不经常使用的列不要建立索引,无意义且增加写操作开销与磁盘开销
3.如第二点所述,经常要更新也即执行写操作的列不要建立索引
4.稀疏数据列不要建立索引,比如性别列,过滤效果差
5.数据变更需要维护索引,索引越多维护成本越高
6.索引越多需要的存储空间越多
